% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/components.R
\name{BaseComponent}
\alias{BaseComponent}
\title{Root component that have no parent,}
\description{
need to be called with input, output and session. it should not be used directly,
only using \code{\link{component}} function.
}
\section{Methods}{

\describe{
  \item{Documentation}{For full documentation of each method go to https://stash.intranet.roche.com/stash/projects/DIVOS/repos/battery/browse}
  \item{\code{BaseComponent$new(...)}}{This method is used to create base battery object, it should never be created directly. Battery components should be created as inherited from this BaseComponent, but this should be done only using \code{component} function}
  \item{\code{getById}}{Method return component with specific id}
  \item{\code{appendChild}}{Method add battery component as child this current component}
  \item{\code{removeChild}}{Method remove child component complementary to appendChild}
  \item{\code{ns}}{Method used to create namespaced identifier}
  \item{\code{createEvent}}{Method will create battery event}
  \item{\code{emit}}{Propagate events from child to parent}
  \item{\code{broadcast}}{Propagate events from parent to all children}
  \item{\code{connect}}{Helper method that will create binding between input event from shiny and battery event}
  \item{\code{disconnect}}{Method remove binding between input element and compnents events}
  \item{\code{on}}{Add event listener to given internal event or native input}
  \item{\code{off}}{Method removes event listener(s) added by \code{on}}
  \item{\code{class}}{Method return name of this class - same as classname when crating the class}
  \item{\code{destroy}}{Method remove all observers created for this component}
  \item{\code{finalize}}{R6Class method that will be called when object is destroyed}
  \item{\code{addService}}{Method dynamically add service to battery component system}
  \item{\code{template}}{Helper method that create \code{shiny::htmlTemplate} with self and private as defaults variables}
  \item{\code{path}}{Method return path to the object in battery components tree}
  \item{\code{log}}{Method log messages that can be listen to with \code{logger} helper}
  \item{\code{logger}}{Shortcut function to add listener to logger}
  \item{\code{render}}{Function that should be overwritten in battery component}
}
native R6 class constructor

this should never be overwriten by child components, they should only
overwrite constructor that is not as problematic when not called super
}

\examples{

## ------------------------------------------------
## Method `BaseComponent$ns`
## ------------------------------------------------

\dontrun{
 battery::component(
   classname = "Plot",
   public = list(
     constructor = function() {
       self$output[[ self$ns("plot") ]] <- renderPlot({
         ## ...
       })
    },
    render = function() {
      shiny::div(
        class = "container",
        plotOutput(self$ns("plot"))
      )
    }
  )
)
}

## ------------------------------------------------
## Method `BaseComponent$emit`
## ------------------------------------------------

\dontrun{
App <- battery::component(
  classname = "App",
  public = list(
    constructor = function() {
      self$on("update", function() {
        print("I need to update")
      })
      panel <- Panel$new(parent = self, component.name = "panel")
      self$outptu[[self$ns("panel")]] <- renderUI({
         panel$render()
      })
    },
    render = function() {
      shiny::tags$div(
        #...
        uiOutput(self$ns("panel"))
      )
    }
  )
)
Panel <- battery::component(
  classname = "Panel",
  public = list(
    constructor = function() {
      self$on(self$ns("button"), function() {
        self$emit("update")
      }, input = TRUE)
    },
    render = function() {
       shiny::tags$div(
          #...
          actionButton(self$ns("button"), "Click Me")
       )
    }
  )
)
## clicking on button will emit the event to the parent and print the message
}

## ------------------------------------------------
## Method `BaseComponent$broadcast`
## ------------------------------------------------

\dontrun{
App <- battery::component(
  classname = "App",
  public = list(
    count = 0,
    constructor = function() {
      self$label <- label
      self$on(self$ns("button"), function() {
        self$count <- self$count + 2
        self$broadcast("update", paste0("Update_number_", count))
      }, input = TRUE)
      counter <- Counter$new(parent = self, component.name = "counter")
      self$outptu[[self$ns("counter")]] <- renderUI({
         panel$render()
      })
    },
    inc = function(count) {
      self$label <- paste0("label_", count)
    },
    render = function() {
      shiny::tags$div(
        actionButton(self$ns("button"), "Click Me"),
        uiOutput(self$ns("counter"))
      )
    }
  )
)
Counter <- battery::component(
  classname = "Counter",
  public = list(
    counter = 0,
    constructor = function() {
      self$createEvent("update")
    },
    render = function() {
       self$counter <- self$counter + 1
       shiny::tags$div(
          paste("Counter", self$counter),
          self$events$update$value
       )
    }
  )
)
## first it will render the child with "Counter 1" (the value of events reactive
## reactive variable will be NULL, default value of events)
## after clicking the button it will increase the count in App by 2
## send event to children and it will in turn trigger render child again
## so it will display "Counter 2" and "Update_number_2"
##
## child render will be called twice and event handler on button once
}

## ------------------------------------------------
## Method `BaseComponent$on`
## ------------------------------------------------

\dontrun{

self$on(self$ns("inputValue"), function(value) {
   print(paste("Input value is ", value))
}, input = TRUE)

self$on(self$ns("save"), function() {
   print("user click save")
}, input = TRUE)


self$on("event", function(value, target) {
  ## this event can be fired with trigger/emit/broadcast
})
}
}
\keyword{architecture}
\keyword{components}
\keyword{structure}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{id}}{- string that}

\item{\code{name}}{- component instance name, set using \code{parent$appendChild(name)} or
\code{component$new(parent = self, component.name = name)}}

\item{\code{services}}{- environment that hold static services - objects shared across battery components
tree. Services can be added using \code{component$addService(name, ANY)}}

\item{\code{events}}{- environment that will hold reactive values added by on or createEvent method}

\item{\code{parent}}{- parent component}

\item{\code{children}}{- list of components that are children of the component, this list will be used to
when using \code{component$broadcast("name")}}

\item{\code{input}}{- shiny input object added in constructor of root class or inherited from parent}

\item{\code{output}}{- shiny output object added in constructor of root class or inherited from parent}

\item{\code{session}}{- shiny session object added in constructor of root class or inherited from parent}

\item{\code{static}}{- environment that can be used to save property into class, it will be shared
with all instances of same battery component.}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{BaseComponent$new()}}
\item \href{#method-getById}{\code{BaseComponent$getById()}}
\item \href{#method-appendChild}{\code{BaseComponent$appendChild()}}
\item \href{#method-removeChild}{\code{BaseComponent$removeChild()}}
\item \href{#method-ns}{\code{BaseComponent$ns()}}
\item \href{#method-createEvent}{\code{BaseComponent$createEvent()}}
\item \href{#method-trigger}{\code{BaseComponent$trigger()}}
\item \href{#method-emit}{\code{BaseComponent$emit()}}
\item \href{#method-broadcast}{\code{BaseComponent$broadcast()}}
\item \href{#method-connect}{\code{BaseComponent$connect()}}
\item \href{#method-disconnect}{\code{BaseComponent$disconnect()}}
\item \href{#method-on}{\code{BaseComponent$on()}}
\item \href{#method-off}{\code{BaseComponent$off()}}
\item \href{#method-class}{\code{BaseComponent$class()}}
\item \href{#method-destroy}{\code{BaseComponent$destroy()}}
\item \href{#method-finalize}{\code{BaseComponent$finalize()}}
\item \href{#method-addService}{\code{BaseComponent$addService()}}
\item \href{#method-template}{\code{BaseComponent$template()}}
\item \href{#method-path}{\code{BaseComponent$path()}}
\item \href{#method-log}{\code{BaseComponent$log()}}
\item \href{#method-logger}{\code{BaseComponent$logger()}}
\item \href{#method-render}{\code{BaseComponent$render()}}
\item \href{#method-clone}{\code{BaseComponent$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\if{latex}{\out{\hypertarget{method-new}{}}}
\subsection{Method \code{new()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{BaseComponent$new(
  input = NULL,
  output = NULL,
  session = NULL,
  parent = NULL,
  component.name = NULL,
  services = NULL,
  spy = FALSE,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{input}}{- shiny input object added in constructor of root class or inherited from parent}

\item{\code{output}}{- shiny output object added in constructor of root class or inherited from parent}

\item{\code{session}}{- shiny session object added in constructor of root class or inherited from parent}

\item{\code{parent}}{- parent battery component, if used you don't need to add
\code{input}, \code{output} and \code{session}}

\item{\code{component.name}}{- name of the component to be used in component$parent$children}

\item{\code{services}}{- list of any static services that can be created on component initialization}

\item{\code{spy}}{- used in unit test to record component method calls (only user methods are recorded)}

\item{\code{...}}{- everything else is passed to \code{constructor} method that should be used in
             user components
Method return component with specific id

it will search the tree of components find name with specific id}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-getById"></a>}}
\if{latex}{\out{\hypertarget{method-getById}{}}}
\subsection{Method \code{getById()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{BaseComponent$getById(id)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{id}}{- string - id of the component to search}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Battery component
Method add battery component as child this current component

this function is called if you pass component.name to constructor
otherwise it should be called to create proper tree. This is required
so \code{component$broadcast} and \code{component$emit} work properly
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-appendChild"></a>}}
\if{latex}{\out{\hypertarget{method-appendChild}{}}}
\subsection{Method \code{appendChild()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{BaseComponent$appendChild(name, child)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{name}}{- string to be used as name}

\item{\code{child}}{- battery component
Method remove child component complementary to appendChild

it can be used with name or the component}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-removeChild"></a>}}
\if{latex}{\out{\hypertarget{method-removeChild}{}}}
\subsection{Method \code{removeChild()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{BaseComponent$removeChild(name = NULL, child)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{name}}{- name of the component to remove}

\item{\code{child}}{- battery component to remove
Method used to create namespaced identifier}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ns"></a>}}
\if{latex}{\out{\hypertarget{method-ns}{}}}
\subsection{Method \code{ns()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{BaseComponent$ns(name)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{name}}{- name to be used inside shiny input or output}
}
\if{html}{\out{</div>}}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
 battery::component(
   classname = "Plot",
   public = list(
     constructor = function() {
       self$output[[ self$ns("plot") ]] <- renderPlot({
         ## ...
       })
    },
    render = function() {
      shiny::div(
        class = "container",
        plotOutput(self$ns("plot"))
      )
    }
  )
)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-createEvent"></a>}}
\if{latex}{\out{\hypertarget{method-createEvent}{}}}
\subsection{Method \code{createEvent()}}{
Method will create battery event

this event can be triggered from R code it can also be broadcasted
this function is called automatically when using on to create observer
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{BaseComponent$createEvent(name, value = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{name}}{- string, name of the event}

\item{\code{value}}{- initial value of the event reactive variable}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-trigger"></a>}}
\if{latex}{\out{\hypertarget{method-trigger}{}}}
\subsection{Method \code{trigger()}}{
Method will trigger the event. It call every observer and invalidate
every reactive context
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{BaseComponent$trigger(name, data = NULL, .force = TRUE, .level = 0)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{name}}{- name of the event to fire}

\item{\code{data}}{- data to be used to trigger the event if function use}

\item{\code{.force}}{- internal option to disable forcing of reactive events}

\item{\code{.level}}{- internal option for logger, that is used to created indent}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-emit"></a>}}
\if{latex}{\out{\hypertarget{method-emit}{}}}
\subsection{Method \code{emit()}}{
Propagate events from child to parent

it will recursivly walk whole tree, and trigger only events that
have reactive values added with \code{createEvent} it will also trigger
all observers added with \code{on}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{BaseComponent$emit(
  name,
  value = NULL,
  target = NULL,
  include.self = FALSE,
  .level = 0
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{name}}{- name of the event to propagate}

\item{\code{value}}{- optional value to to set on reactive values (it will be
access from component$events or inside observer}

\item{\code{target}}{- optioanl target that should be passed along the event
can only be access from event handler added by \code{component$on}}

\item{\code{include.self}}{- shoult it also trigger on this component or only
on children}

\item{\code{.level}}{- internal option for logger, that is used to created indent}
}
\if{html}{\out{</div>}}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
App <- battery::component(
  classname = "App",
  public = list(
    constructor = function() {
      self$on("update", function() {
        print("I need to update")
      })
      panel <- Panel$new(parent = self, component.name = "panel")
      self$outptu[[self$ns("panel")]] <- renderUI({
         panel$render()
      })
    },
    render = function() {
      shiny::tags$div(
        #...
        uiOutput(self$ns("panel"))
      )
    }
  )
)
Panel <- battery::component(
  classname = "Panel",
  public = list(
    constructor = function() {
      self$on(self$ns("button"), function() {
        self$emit("update")
      }, input = TRUE)
    },
    render = function() {
       shiny::tags$div(
          #...
          actionButton(self$ns("button"), "Click Me")
       )
    }
  )
)
## clicking on button will emit the event to the parent and print the message
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-broadcast"></a>}}
\if{latex}{\out{\hypertarget{method-broadcast}{}}}
\subsection{Method \code{broadcast()}}{
Propagate events from parent to all children

methods similar to \code{emit} but it propagete event to children
if called on root component it will send message to all components
inside the tree.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{BaseComponent$broadcast(
  name,
  value = NULL,
  target = NULL,
  include.self = FALSE,
  .level = 0
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{name}}{- string - name of the component to trigger}

\item{\code{value}}{- default value adde to component$events}

\item{\code{target}}{- string that indicate which battery component trigger the event
it can be omited if so it will use same object that called the method}

\item{\code{include.self}}{- flag that indicate if event should also be called on self}

\item{\code{.level}}{- internal option for logger, that is used to created indent}
}
\if{html}{\out{</div>}}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
App <- battery::component(
  classname = "App",
  public = list(
    count = 0,
    constructor = function() {
      self$label <- label
      self$on(self$ns("button"), function() {
        self$count <- self$count + 2
        self$broadcast("update", paste0("Update_number_", count))
      }, input = TRUE)
      counter <- Counter$new(parent = self, component.name = "counter")
      self$outptu[[self$ns("counter")]] <- renderUI({
         panel$render()
      })
    },
    inc = function(count) {
      self$label <- paste0("label_", count)
    },
    render = function() {
      shiny::tags$div(
        actionButton(self$ns("button"), "Click Me"),
        uiOutput(self$ns("counter"))
      )
    }
  )
)
Counter <- battery::component(
  classname = "Counter",
  public = list(
    counter = 0,
    constructor = function() {
      self$createEvent("update")
    },
    render = function() {
       self$counter <- self$counter + 1
       shiny::tags$div(
          paste("Counter", self$counter),
          self$events$update$value
       )
    }
  )
)
## first it will render the child with "Counter 1" (the value of events reactive
## reactive variable will be NULL, default value of events)
## after clicking the button it will increase the count in App by 2
## send event to children and it will in turn trigger render child again
## so it will display "Counter 2" and "Update_number_2"
##
## child render will be called twice and event handler on button once
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-connect"></a>}}
\if{latex}{\out{\hypertarget{method-connect}{}}}
\subsection{Method \code{connect()}}{
Helper method that will create binding between input event from shiny and battery event
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{BaseComponent$connect(event, elementId)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{event}}{- name of the event}

\item{\code{elementId}}{- id of the HTML element (shiny input it should be value from \code{self$ns})}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-disconnect"></a>}}
\if{latex}{\out{\hypertarget{method-disconnect}{}}}
\subsection{Method \code{disconnect()}}{
Method remove binding between input element and compnents events

complementary to connect
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{BaseComponent$disconnect(elementId)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{elementId}}{- it of the input element}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-on"></a>}}
\if{latex}{\out{\hypertarget{method-on}{}}}
\subsection{Method \code{on()}}{
Add event listener to given internal event or native input
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{BaseComponent$on(
  events,
  handler,
  input = FALSE,
  enabled = TRUE,
  single = TRUE,
  debounceMillis = NULL,
  once = FALSE,
  ignoreNULL = TRUE,
  init = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{events}}{- character or character vector of internal event or input id}

\item{\code{handler}}{- function that can have value and target parameters (optional)}

\item{\code{input}}{- boolean that's indicate if event should be added to input
otherwise it's internal battery event}

\item{\code{enabled}}{- boolean that enable event to easy toggle event}

\item{\code{single}}{- if used it will create only one event, it will always destroy old one}

\item{\code{debounceMillis}}{- if not NULL it will use \code{shiny::debounce} on the function}

\item{\code{once}}{- argument works the same as in \code{shiny::observeEvent}}

\item{\code{ignoreNULL}}{- argument works the same as in \code{shiny::observeEvent}}

\item{\code{init}}{- indicate if event should be triggered on init}
}
\if{html}{\out{</div>}}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{

self$on(self$ns("inputValue"), function(value) {
   print(paste("Input value is ", value))
}, input = TRUE)

self$on(self$ns("save"), function() {
   print("user click save")
}, input = TRUE)


self$on("event", function(value, target) {
  ## this event can be fired with trigger/emit/broadcast
})
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-off"></a>}}
\if{latex}{\out{\hypertarget{method-off}{}}}
\subsection{Method \code{off()}}{
Method removes event listener(s) added by \code{on}

if handler is NULL it will remove all listeners for a given event name
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{BaseComponent$off(events, handler = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{events}}{- vector or string with names of events to remove}

\item{\code{handler}}{- optional event handler}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-class"></a>}}
\if{latex}{\out{\hypertarget{method-class}{}}}
\subsection{Method \code{class()}}{
Method return name of this class - same as classname when crating the class
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{BaseComponent$class()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
string - class name
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-destroy"></a>}}
\if{latex}{\out{\hypertarget{method-destroy}{}}}
\subsection{Method \code{destroy()}}{
Method dfestroy component

It removes all observers created for this component also clear
it also use other clean ups.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{BaseComponent$destroy()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-finalize"></a>}}
\if{latex}{\out{\hypertarget{method-finalize}{}}}
\subsection{Method \code{finalize()}}{
R6Class method that will be called when object is destroyed
it just calls \code{destroy}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{BaseComponent$finalize()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-addService"></a>}}
\if{latex}{\out{\hypertarget{method-addService}{}}}
\subsection{Method \code{addService()}}{
Method dynamically add service to battery component system

only one service with giben name can be added to the tree
same object will be accessed in every component in the tree.
there is one default service logger that is \code{EventEmitter}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{BaseComponent$addService(name, service)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{name}}{- name of the service by which you access the service
e.g. self$service$foo}

\item{\code{service}}{- object used as service - it can be any object}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-template"></a>}}
\if{latex}{\out{\hypertarget{method-template}{}}}
\subsection{Method \code{template()}}{
Helper method that create \code{shiny::htmlTemplate}
with self and private as defaults variables to be used in html (inside {{ }})
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{BaseComponent$template(filename, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{filename}}{- name of the template}

\item{\code{...}}{- any number of arguments that will be accessible in
template}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-path"></a>}}
\if{latex}{\out{\hypertarget{method-path}{}}}
\subsection{Method \code{path()}}{
Method return path to the object in battery components tree
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{BaseComponent$path()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
vector of strings of id of the components in the tree
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-log"></a>}}
\if{latex}{\out{\hypertarget{method-log}{}}}
\subsection{Method \code{log()}}{
Method log message that can be listen to, best way to add listener
is to use self$logger("name", fn) in root component constructor
each event is triggered with list(id, type, path, message, args)
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{BaseComponent$log(levels, message, type = "battery", ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{levels}}{- vector of characters to listen (default names in battery
are "battery" and "info")}

\item{\code{message}}{- message to log}

\item{\code{type}}{- default battery - additional value to distinguish the message
in battery type is name of the method - or "method" inside user method}

\item{\code{...}}{- any arguments are added into args property}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-logger"></a>}}
\if{latex}{\out{\hypertarget{method-logger}{}}}
\subsection{Method \code{logger()}}{
Shortcut function to add listener to logger
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{BaseComponent$logger(level, fn)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{level}}{- character vector or character of log levels to listen}

\item{\code{fn}}{- function handler}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-render"></a>}}
\if{latex}{\out{\hypertarget{method-render}{}}}
\subsection{Method \code{render()}}{
Function that should be overwritten in battery component

this is convention that this function should return HTML (shiny tags)
this function can have reactive value self$events.
render function should not have children render if possible becasue
update of parent will rerender the children. The proper way is to use
renderUI in constructor and renderUI in render function for the children.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{BaseComponent$render()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
overwriten render by convention should return shiny tags
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-clone"></a>}}
\if{latex}{\out{\hypertarget{method-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{BaseComponent$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
